#pragma once
#include <cmath>
#include "Vector3.h"
#include "Quat.h"

class Mat4 {
public:
    float data[16]; // row-major

    Mat4() {
        for (int i = 0; i < 16; i++) data[i] = 0.0f;
        data[0] = data[5] = data[10] = data[15] = 1.0f;
    }

    // ?? Multiplication ????????????????????????????????????????????????????
    Mat4 operator*(const Mat4& other) const {
        Mat4 r;
        for (int row = 0; row < 4; row++)
            for (int col = 0; col < 4; col++) {
                r.data[row * 4 + col] = 0;
                for (int k = 0; k < 4; k++)
                    r.data[row * 4 + col] += data[row * 4 + k] * other.data[k * 4 + col];
            }
        return r;
    }

    // ?? Translation ???????????????????????????????????????????????????????
    static Mat4 translate(const Vector3& v) {
        Mat4 m;
        m.data[12] = v.x;
        m.data[13] = v.y;
        m.data[14] = v.z;
        return m;
    }

    // ?? Scale ?????????????????????????????????????????????????????????????
    static Mat4 scale(const Vector3& v) {
        Mat4 m;
        m.data[0] = v.x;
        m.data[5] = v.y;
        m.data[10] = v.z;
        return m;
    }

    // ?? Rotation ??????????????????????????????????????????????????????????
    static Mat4 rotateX(float deg) {
        float c = cos(radians(deg)), s = sin(radians(deg));
        Mat4 m;
        m.data[5] = c; m.data[6] = s;
        m.data[9] = -s; m.data[10] = c;
        return m;
    }

    static Mat4 rotateY(float deg) {
        float c = cos(radians(deg)), s = sin(radians(deg));
        Mat4 m;
        m.data[0] = c; m.data[2] = -s;
        m.data[8] = s; m.data[10] = c;
        return m;
    }

    static Mat4 rotateZ(float deg) {
        float c = cos(radians(deg)), s = sin(radians(deg));
        Mat4 m;
        m.data[0] = c; m.data[1] = s;
        m.data[4] = -s; m.data[5] = c;
        return m;
    }

    // ?? Perspective ???????????????????????????????????????????????????????
    static Mat4 perspective(float fovDeg, float aspect, float near, float far) {
        float f = 1.0f / tan(radians(fovDeg) / 2.0f);
        Mat4 m;
        m.data[0] = f / aspect;
        m.data[5] = f;
        m.data[10] = (far + near) / (near - far);
        m.data[11] = -1.0f;
        m.data[14] = (2.0f * far * near) / (near - far);
        m.data[15] = 0.0f;
        return m;
    }

    // ?? Orthographic ??????????????????????????????????????????????????????
    static Mat4 ortho(float left, float right, float bottom, float top, float near, float far) {
        Mat4 m;
        m.data[0] = 2.0f / (right - left);
        m.data[5] = 2.0f / (top - bottom);
        m.data[10] = -2.0f / (far - near);
        m.data[12] = -(right + left) / (right - left);
        m.data[13] = -(top + bottom) / (top - bottom);
        m.data[14] = -(far + near) / (far - near);
        m.data[15] = 1.0f;
        return m;
    }

    // ?? LookAt ????????????????????????????????????????????????????????????
    static Mat4 lookAt(const Vector3& eye, const Vector3& center, const Vector3& up) {
        Vector3 f = (center - eye).normalized();
        Vector3 r = f.cross(up).normalized();
        Vector3 u = r.cross(f).normalized();

        Mat4 m;
        m.data[0] = r.x;  m.data[1] = u.x;  m.data[2] = -f.x;  m.data[3] = 0.0f;
        m.data[4] = r.y;  m.data[5] = u.y;  m.data[6] = -f.y;  m.data[7] = 0.0f;
        m.data[8] = r.z;  m.data[9] = u.z;  m.data[10] = -f.z;  m.data[11] = 0.0f;
        m.data[12] = -r.dot(eye);
        m.data[13] = -u.dot(eye);
        m.data[14] = f.dot(eye);
        m.data[15] = 1.0f;
        return m;
    }

    // ?? From Quat ?????????????????????????????????????????????????????????
    static Mat4 fromQuat(const Quat& q) {
        float xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;
        float xy = q.x * q.y, xz = q.x * q.z, yz = q.y * q.z;
        float wx = q.w * q.x, wy = q.w * q.y, wz = q.w * q.z;

        Mat4 m;
        m.data[0] = 1 - 2 * (yy + zz); m.data[1] = 2 * (xy + wz);    m.data[2] = 2 * (xz - wy);    m.data[3] = 0;
        m.data[4] = 2 * (xy - wz);     m.data[5] = 1 - 2 * (xx + zz); m.data[6] = 2 * (yz + wx);    m.data[7] = 0;
        m.data[8] = 2 * (xz + wy);     m.data[9] = 2 * (yz - wx);    m.data[10] = 1 - 2 * (xx + yy); m.data[11] = 0;
        m.data[12] = 0;             m.data[13] = 0;             m.data[14] = 0;             m.data[15] = 1;
        return m;
    }

    // ?? TRS combined ??????????????????????????????????????????????????????
    static Mat4 trs(const Vector3& pos, const Quat& rot, const Vector3& scl) {
        return translate(pos) * fromQuat(rot) * scale(scl);
    }

    // ?? Transpose ?????????????????????????????????????????????????????????
    Mat4 transpose() const {
        Mat4 r;
        for (int row = 0; row < 4; row++)
            for (int col = 0; col < 4; col++)
                r.data[row * 4 + col] = data[col * 4 + row];
        return r;
    }

    // ?? Vector multiply ???????????????????????????????????????????????????
    Vector3 multiplyVec(const Vector3& v, float w = 1.0f) const {
        Vector3 r;
        r.x = data[0] * v.x + data[1] * v.y + data[2] * v.z + data[3] * w;
        r.y = data[4] * v.x + data[5] * v.y + data[6] * v.z + data[7] * w;
        r.z = data[8] * v.x + data[9] * v.y + data[10] * v.z + data[11] * w;
        float wOut = data[12] * v.x + data[13] * v.y + data[14] * v.z + data[15] * w;
        if (wOut != 0.0f) { r.x /= wOut; r.y /= wOut; r.z /= wOut; }
        return r;
    }

    float* getData() { return data; }
    const float* getData() const { return data; }

    static float radians(float deg) { return deg * 3.14159265359f / 180.0f; }
};