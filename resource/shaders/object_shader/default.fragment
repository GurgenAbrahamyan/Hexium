#version 330 core
out vec4 FragColor;

in vec2 vUV;
in vec3 vNormal;
in vec3 vCrntPos;
in vec3 vColor;

uniform sampler2D tex0; // Albedo
uniform sampler2D tex1; // Specular/roughness/metallic etc.
uniform vec3 cameraPos;


struct GPULight {
    int type;         // 0 = point, 1 = directional, 2 = spot
    float intensity;  // light strength
    vec2 pad0;        // padding to make 16 bytes
    vec3 color;
    float pad1;
    vec3 position;
    float pad2;
    vec3 direction;
    float pad3;
    float innerCone;
    float outerCone;
    vec2 pad4;
};

layout(std140) uniform LightBlock {
    GPULight lights[32]; // max 32 lights
    int lightCount;
    vec3 pad5;           // pad to 16 bytes
};


vec3 calcPointLight(GPULight light, vec3 normal, vec3 viewDir, vec3 albedo, float specularMap) {
    vec3 lightVec = light.position - vCrntPos;
    float distance = length(lightVec);
    vec3 L = normalize(lightVec);
    
    float attenuation = 1.0 / (0.01 * distance * distance + 0.001 * distance + 1.0);
    
   
    float diffuse = max(dot(normal, L), 0.0);
    
   
    vec3 H = normalize(L + viewDir);
    float spec = pow(max(dot(normal, H), 0.0), 32.0) * specularMap; // Higher exponent for Blinn-Phong
    
    return (albedo * diffuse + spec) * light.color * light.intensity * attenuation;
}

vec3 calcDirectionalLight(GPULight light, vec3 normal, vec3 viewDir, vec3 albedo, float specularMap) {
    vec3 L = normalize(-light.direction);
    
    
    float diffuse = max(dot(normal, L), 0.0);
    
    
    vec3 H = normalize(L + viewDir);
    float spec = pow(max(dot(normal, H), 0.0), 32.0) * specularMap;
    
    return (albedo * diffuse + spec) * light.color * light.intensity;
}

vec3 calcSpotLight(GPULight light, vec3 normal, vec3 viewDir, vec3 albedo, float specularMap) {
    vec3 lightVec = light.position - vCrntPos;
    float distance = length(lightVec);
    vec3 L = normalize(lightVec);
    
    
    float theta = dot(L, normalize(-light.direction));
    float epsilon = light.innerCone - light.outerCone;
    float intensity = clamp((theta - light.outerCone) / epsilon, 0.0, 1.0);
    
    float attenuation = 1.0 / (0.01 * distance * distance + 0.001 * distance + 1.0);
    
    
    float diffuse = max(dot(normal, L), 0.0);
    
  
    vec3 H = normalize(L + viewDir);
    float spec = pow(max(dot(normal, H), 0.0), 32.0) * specularMap;
    
    return (albedo * diffuse + spec) * light.color * light.intensity * attenuation * intensity;
}

void main() {
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(cameraPos - vCrntPos);
    
    vec3 albedo = texture(tex0, vUV).rgb;
    float specMap = texture(tex1, vUV).r;
    
    vec3 ambient = albedo * 0.10; 
    vec3 result = ambient;
    
    for (int i = 0; i < lightCount; i++) {
        GPULight light = lights[i];
        
        if (light.type == 0) {
            result += calcPointLight(light, normal, viewDir, albedo, specMap);
        } else if (light.type == 1) {
            result += calcDirectionalLight(light, normal, viewDir, albedo, specMap);
        } else if (light.type == 2) {
            result += calcSpotLight(light, normal, viewDir, albedo, specMap);
        }
    }
    
   
    FragColor = vec4(result, 1.0);
}